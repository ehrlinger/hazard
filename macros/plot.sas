/* <2003-10-17>
%**************************************************************************************;
%* Macro plot                                    Richard Mailhot                       ;
%*                                                                                     ;
%* The macro variable BY is global and originates from the _by macro                   ;
%*                                                                                     ;
%* 08/22/95 Made the following changes;                                                ;
%* Made changes to line 262 changing                                                   ;
%*  %let cmndword=%_Uscan(%str(=;)); to %let cmndword=%_Uscan(%str(=;,));              ;
%* This was done to eliminate errors when the following syntax is  used                ;
%*      goptions device=ljivps ,end;  <= the space before the comma caused problems    ;
%*                                                                                     ;
%* Made changes to lines 817 and 851 where _uscan(%str( )) was changed to              ;
%* _uscan(%str(; )) This was done to allow the NOTES command to work                   ;
%*                                                                                     ;
%* 08/24/95 Made the following changes                                                 ;
%* changed xaxislen=yaxislen * 1.66667 to xaxislen=yaxislen * 1.5                      ;
%* changed yaxislen=yinch * 65 to yaxislen=yinch * .68                                 ;
%* changed default setting of  linecl=2 to linecl=21                                   ;
%*                                                                                     ;
%* 08/28/95 Made the following changes                                                 ;
%* If an ORDER is given, any data points and plot lines that have end points outside   ;
%* of the range given in the order statement will not be included in the plot.  This   ;
%* creates some rather odd looking plots.  The basic problem is that the proc gplot    ;
%* doesn t clip an abstract "window" to the "viewport" created by the ORDER statement  ;
%* To add back the missing line segments we must find the Minimum and Maximum of the   ;
%* ORDER statement and use them to create the missing plot lines that extend out side  ;
%* the range given in the ORDER statement                                              ;
%*                                                                                     ;
%* To make this "correction" I have added bldano_c and  changed the axis, plot and     ;
%* bld_anno macros.                                                                    ;
%*                                                                                     ;
%* In the axis macro the 4 global variables xmax xmin ymax ymin are                    ;
%* updated based on the contents of the ORDER variable.                                ;
%*                                                                                     ;
%* In the plot macro the data points are tested against the range for 2 conditions     ;
%* (1) if the previous point is outside the range and the current point is inside the  ;
%* range then a line segment is plotted to draw between the axis and the point within  ;
%* the range.  Where the point on the axis is determined using the point slope formula ;
%* (2) if the previous point is inside the range and the current point is outside the  ;
%* range, then a line segment is plotted to draw between the previous point and the    ;
%* axis. Where the point on the axis is determined by using the point slope formula.   ;
%*                                                                                     ;
%* In the bld_anno macro the creation of end bars is controlled by the condition if    ;
%* value is in range maxaxis to minaxis, & error bar length is limited to this range   ;
%*                                                                                     ;
%* Added XAXISRAT flag to GOPTIONS statement, this sets the size of the y axis as a    ;
%* ratio of x axis to y axis. The default is y=1.5 * xaxislength                       ;
%*                                                                                     ;
%* 08/30/95 NOTE NOTE....  Concerning the "clipping" problem....                       ;
%* Well, life is stranger then fiction.  The ORDER statement problem described earlier ;
%* is even stranger then I  thought. If the points are out side the bounds given in    ;
%* the ORDER statement they are treated as missing.   SAS mentioned using a skipmiss   ;
%* statement at the end of the plot command in the proc gplot statement.  If you use   ;
%* the mode=include directive in the symbol statement this works for points that are   ;
%* lower bound, but doesn't work for those points that lie above the upper bound.  If  ;
%* you don't use the mode=include directive the results are just the opposite.         ;
%* To "fix" this you have to manually set the points that are out of bounds to         ;
%* missing, after you have used these points to create the line segments that project  ;
%* off the axis scale                                                                  ;
%* Right now I'm debating if I should use annotate to draw all lines...                ;
%*                                                                                     ;
%* 09/05/95 NOTE .... Concerning the "clipping" problem....                            ;
%* The skipmiss statement was removed from the proc gplot statement because it caused  ;
%* "divots" in dashed lines and changed the size of the dashes.  Life goes on...       ;
%*                                                                                     ;
%* 09/05/95 Added connect macro                                                        ;
%*                                                                                     ;
%* 09/06/95 Added rmvblnk macro.  This macro prepares the plot macro input stream      ;
%* It removes blanks except if they are enclosed in quotes, and seperates              ;
%* command=value pairs by commas.  Any input surrounded by parenthesis are seperated   ;
%* by blanks.  This routine was written to alleviate problems associated with comma and;
%* blanks in the input data stream by standardizing the input stream                   ;
%*                                                                                     ;
%* 09/07/95 Changed _label so LOGO labels in quadrant 1 and 4 are left justified to    ;
%* the point defined by p=XORIGIN + XAXISLEN - MAXLEN.  Where XORIGIN is the x         ;
%* coordinate of the left end of the xaxis, XAXISLEN is the length of the x axis and   ;
%* MAXLEN is the maximum length of any given line in that LOGO statement.              ;
%* Changed the _label macro variable linespac so it would reflect changes to the       ;
%* character size given in via the H flag.                                             ;
%*                                                                                     ;
%* 09/07/95 Changed axis macro, added the MAJOR=NONE and MINOR=NONE flags              ;
%*                                                                                     ;
%* 09/12/95 Worked on several things.... changed the way FONT is built in _plot        ;
%* changed BY_EXST in _plot embedded &cmndword ne END in quotes in connect             ;
%* added yflg to initialization list in plot                                           ;
%*                                                                                     ;
%* Peculiarities:  Doesn't handle recursive parenthesis in the _plot macro  WHERE      ;
%* clauses associated with set names get fouled up in the rmvblnk routine              ;
%*                                                                                     ;
%* 11/22/95 to 11/27/95 Removed rmblnk, _scan and _uscan routines.  Added              ;
%* token routine                                                                       ;
%* Token is a parser that recognizes blanks, commas, equal signs, quotes and           ;
%* parenthesis.  It will be substituted for the _scan routines where possible.         ;
%* This routine should be the solution to parsing problems. It is a little more        ;
%* processor intensive but a lot better in operation.                                  ;
%*                                                                                     ;
%* 11/28/95 Worked on the _Plot macro to fix the problems associated with where/rename ;
%* /retain... clauses being used with the data set name in the set statement of the    ;
%* tuple command                                                                       ;
%*                                                                                     ;
%* 11/28/95 Worked on the Label macro.  Changed the way that logo(1,4)'s 1stx and 1sty ;
%* are calculated. These variables determine the left-justification.                   ;
%*                                                                                     ;
%* 02/07/96 Changed the Bounds macro, bumped calculated values of xmax xmin ymax ymin  ;
%* added yminflag, xminflag tests to Anno_c and Bounds macro.                          ;
%* These changes were incorporated to relieve problems associated with plots where     ;
%* order=( by ) sets xmax and ymax to be greater then max values in the data           ;
%*                                                                                     ;
%* Changed the Axis macro, altered the test for Minor=NONE statement, need to make     ;
%* similar change to Major=NONE test statement                                         ;
%*                                                                                     ;
%* 02/15/1996                                                                          ;
%* Changed adj_symb macro to include put('WIDTH',put(&WIDTH*&LINWIDTH,8.5));           ;
%* and changed _Plot %let &width=&linwidth to &width=1                                 ;
%*                                                                                     ;
%* For some reason the clip alg. is busted for err bars on lines that extend beyond    ;
%* axis. Will have to fix this asap                                                    ;
%*                                                                                     ;
%* 02/19/1996 Did a lot of work in the bounds, _label, axis, and bldanno macros.       ;
%* Removed yminflg ymaxflg xminflg xmaxflg and created yflg xflg.  These flags denote  ;
%* the condition where an order command is used in the axis statement.  The work       ;
%* reflect changes in the overall code in regards to testing for the existence of      ;
%* min & max values in the data set.  Additionally, changes to the bounds macro were   ;
%* made to allow the plotting of a single data point, along with notes in the README   ;
%* file concerning the limitations in the macro's ability to handle precision.         ;
%*                                                                                     ;
%* 02/20/1996 fixed clip problem.  LINECL performs two duties, sets line type in       ;
%* the symbol stmnt, and as a condition flag in the clipping routines.   Since the     ;
%* symbol stmnt complains if linetype = 0 _plot routine sets linecl = 2 before forming ;
%* the symbol stmnt in _Plot.  Added 1 line of code to reset linecl back to 0 after    ;
%* symbol statement formed in _Plot.                                                   ;
%*                                                                                     ;
%* 03/07/96 added gout option to proc gplot                                            ;
%* 04/12/96 added color capability                                                     ;
%*                                                                                     ;
%* 08/12/96 In the _Plot routine removed call to bldano_c, and loop to remove points   ;
%* outside of axis min-max.  Replace logic with "mode=include" in the Tuple statement. ;
%* Seems to work now,  as opposed to earlier comments.  Difference between then and    ;
%* now is we have upgraded to SAS 6.11                                                 ;
%*                                                                                     ;
%* 07/21/97 Plot line type would appear to change if the plot line extended outside of ;
%* the axis range. This was most apparent in dashed lines.  SAS Inst. told me to       ;
%* include the flag NODASH in the goptions statement.  Seems to correct this           ;
%*                                                                                     ;
%* 09/09/1997 Changed default FTEXT = SWISSB. SAS6.12 changed font weight so we change ;
%* the default behaviour, life goes on......                                           ;
%* 03/22/2002 Changed default FTEXT = SWISS. SAS8.2 changed font weight so we change;
%*                                                                                     ;
%* ----------------------------------------------------------------------------------- ;
%* ----------------------------------------------------------------------------------- ;
%*                                                                                     ;
%* 06/14/2001 Differences were identified between plot output in SAS V6.12             ;
%*              versus V8 -- axes labels not centering correctly, overlaps             ;
%*              at the plot x,y origin, and discrepancies in the value tick            ;
%*              marks and the axes endpoints overlapping (minutely) rather             ;
%*              than joining cleanly                                                   ;
%*            Problem was identified and rectified by determining the version of       ;
%*              SAS being run, then allowing for a alteration to the macro variable    ;
%*              "curlen" within the submacro _Label                                    ;
%*            Christine Skibinski, M.S. CCF-Dept of Biostatistics                      ;
%*                                                                                     ;
%* 08/14/2001 Correction of above changes, EHB                                         ;
%*                                                                                     ;
%**************************************************************************************;
*/

%macro set_size(haxislen,vaxislen,xaxisrat);
%local _target tmp _device _rotate tmp1;
*%*************************************************************************************;
%* Build default values for variables that determine size and position                 ;
%* base upon the old cvplot.f program                                                  ;
%* The base unit for characters, symbols, tickmarks, and labels is the following       ;
%* variable SIZE it is based on the length of the x and y axis                         ;
%* first get graphics output dimensions                                                ;

    options nogwindow;

 %let _target=%scan(&target,2,%str(=));
 %let _device=%scan(&device,2,%str(=));
 %let _rotate=%scan(&rotate,2,%str(=));
 %if %length(&_rotate) > 2 %then %let tmp= rotate %str(=)&_rotate;
 %else %let tmp=%str();
 %if %length(&_target) > 2 %then %let tmp1=&_target;
 %else %let tmp1=&_device;

    goptions reset=all &tmp device=&tmp1;
  data _null_;
    length _xinc _yinc _siz _majrsiz _minrsiz $8;
    length _yaxisle _xaxisle _yorigi _xorigi linspace numsize pixsize logosize xlblpos ylblpos   $8;
    length yaxctr xaxctr $8;
    rc1=ginit();
    rc2=graph('clear');
    call gask('maxdisp',units,xdim,ydim,xpix,ypix,rc3);
    call gask('hsize',hsize,rc4);
    call gask('vsize',vsize,rc5);
    rc5=gterm();
    xinch=xdim/.0254;
    yinch=ydim/.0254;
    if &haxislen + &vaxislen ne 0 then do;
       xaxislen=&haxislen;
       yaxislen=&vaxislen;
    end;
    else do;
       yaxislen=yinch * .68;
       xaxislen=yaxislen * &xaxisrat;
    end;
    size=0.045*yaxislen;
    XORIGIN=yaxislen * .235;
    YORIGIN=yaxislen * .235;
    majrsize=size/2;
    minrsize=majrsize/2;
    linspace=put((size*1.1),8.5);
    pixsize=put((xinch/xpix),8.5);
    numsize=put((size*0.8),8.5);
    logosize=put((size*0.8),8.5);

    yaxctr=put(((YAXISLEN)/2 + YORIGIN),8.5);
    xaxctr=put(((XAXISLEN)/2 + XORIGIN + 0.125),8.5); %* the 0.125 is a fudge factor;
    xlblpos=put((yorigin-(size*3)+0.0625),8.5);       %* the 3 and .1625 are fudge factors;
    tlblpos=put((yinch-(size)+0.0625),8.5);           %* the .1625 is a fudge factors;
    ylblpos=put((xorigin-(size*2)),8.5);              %* the 2 is a fudge factor;

    %if &sysver>=7.0 %then %do; 
      xlblpos=put((yorigin-(size*3.4)+0.1625),8.5);     %* the 3 and .1625 are fudge factors;
      tlblpos=put((yinch-(size)+0.1625),8.5);           %* the .1625 is a fudge factors;
	%end;
 
    _xinc=put(xinch,8.5);
    _yinc=put(yinch,8.5);
    _siz=put(size,8.5);
    _majrsiz=put(majrsize,8.5);
    _minrsiz=put(minrsize,8.5);
    _yaxisle=put(yaxislen,8.5);
    _xaxisle=put(xaxislen,8.5);
    _yorigi=put(yorigin,8.5);
    _xorigi=put(xorigin,8.5);
    call symput('XINCH',_xinc);
    call symput('YINCH',_yinc);
    call symput('SIZE',_siz);
    call symput('MAJRSIZE',_majrsiz);
    call symput('MINRSIZE',_minrsiz);
    call symput('YAXISLEN',_yaxisle);
    call symput('XAXISLEN',_xaxisle);
    call symput('YORIGIN',_yorigi);
    call symput('XORIGIN',_xorigi);
    call symput('LINSPACE',linspace);
    call symput('PIXSIZE',pixsize);
    call symput('NUMSIZE',numsize);
    call symput('LOGOSIZE',logosize);
    call symput('Yaxctr',yaxctr);
    call symput('Xaxctr',xaxctr);
    call symput('Xlblpos',xlblpos);
    call symput('Ylblpos',ylblpos);
    call symput('Tlblpos',tlblpos);
  run;
%mend;

%macro Bld_anno(_zzinzz_,width,ebarwdth,ebarsize,colorpe);
%* This routine builds error bars                                                    ;
%* If an ORDER is given, any data points and plot lines that have end points outside ;
%* of the range given in the order statement will not be included in the plot.  This ;
%* creates some rather odd looking plots.  The basic problem is that the proc gplot  ;
%* doesn t clip an abstract "window" to the "viewport" created by the ORDER statement;
%* To add back the missing line segments we must find the Minimum and Maximum of the ;
%* ORDER statement and use them to correct  plot lines that extend out side          ;
%* the range given in the ORDER statement                                            ;
%Local clen;
***** build annotate data set *******;
    data _zzatzz_;
        set &_zzinzz_;
        length function $8;
        length color $8;
        color="&colorpe";
        attrib xsys ysys format=$1.;
        tmp_x = x;
      if cll&plt_cnt ne . and clu&plt_cnt ne . and x le &xmax and x ge &xmin  then do;
            MinFlgCL=0; MinFlgCU=0; MinFlgY=0;
              if cll&plt_cnt < &ymin then do;
                 cll&plt_cnt = &ymin; MinFlgCL=1;
              end;
              if y&plt_cnt < &ymin then do;
                 y&plt_cnt = &ymin; MinFlgY=1;
              end;
              MaxFlgCL=0; MaxFlgCU=0; MaxFlgY=0;
              if clu&plt_cnt > &ymax then do;
                 clu&plt_cnt = &ymax; MaxFlgCU=1;
              end;
              if y&plt_cnt > &ymax  then do;
                 y&plt_cnt = &ymax; MaxFlgY=1;
              end;
            size=&WIDTH*&EBARWDTH*2/3;
          *create lower error bar;
            if MinFlgY=0 then do;
               function ='move';x=tmp_X;y=y&plt_cnt;xsys='2';ysys='2';output;
               function ='draw';x=tmp_X;y=cll&plt_cnt;xsys='2';ysys='2';output;
               if MinFlgCL=0 and MaxFlgCL=0 then do;
                  function ='move';x=&EBARSIZE/2;xsys='9';ysys='2';output;
                  function ='draw';x=-&EBARSIZE;xsys='9';ysys='2';output;
               end;
            end;
          *create upper error bar;
           if MaxFlgY=0 then do;
              function ='move';x=tmp_X;y=y&plt_cnt;xsys='2';ysys='2';output;
              function ='draw';x=tmp_X;y=clu&plt_cnt;xsys='2';ysys='2';output;
              if MinFlgCU=0 and MaxFlgCU=0 then do;
                 function ='move';x=&EBARSIZE/2;xsys='9';ysys='2';output;
                 function ='draw';x=-&EBARSIZE;xsys='9';ysys='2';output;
              end;
           end;
     end;
     keep function x y xsys ysys size color;
     data _zzanzz_; set _zzanzz_ _zzatzz_;
     run;
     %let annotate=annotate%str(=)_zzanzz_;

%mend;
%macro Bldano_c(width,linepe,linecl,colorpe,colorcl);
%* It is assumed that the data set _zzinzz_ is sorted by X                          ;
%* This macro replaces line segments lost to improper clipping of graph plot to axis;
%* If an ORDER is given, any data points and plot lines that have end points outside ;
%* of the range given in the order statement will not be included in the plot.  This ;
%* creates some rather odd looking plots.  The basic problem is that the proc gplot  ;
%* doesn t clip an abstract "window" to the "viewport" created by the ORDER statement;
%* To add back the missing line segments we must find the Minimum and Maximum of the ;
%* ORDER statement and use them to correct  plot lines that extend out side          ;
%* the range given in the ORDER statement                                            ;
%* See notes at beginning of this macro for details                                 ;


   data _zzatzz_;
        set _zzinzz_;
        retain y_prev x_prev cll_prev clu_prev;
        length function $8; attrib xsys ysys format=$1.;
        length color $8;
        tmp_X=x; ymin=&ymin; ymax=&ymax; xmin=&xmin; xmax=&xmax; size=&WIDTH;

    %* Handle Lines that dip below or above range bounded by ymin and ymax;
    do i=1 to 3;
        if (&linepe > 0 and i=1 and &yflg=1) or (&linecl > 0 and i>1 and &yflg=1) then do;
          xc=tmp_x; xsys='2'; ysys='2';xp=x_prev;
          if i=1 then do; yc=y&plt_cnt;   yp=y_prev;   line=&linepe; color="&colorpe"; end;
          if i=2 then do; yc=cll&plt_cnt; yp=cll_prev; line=&linecl; color="&colorcl"; end;
          if i=3 then do; yc=clu&plt_cnt; yp=clu_prev; line=&linecl; color="&colorcl"; end;

          %* Handle Lines that dip below or above range bounded by ymin and ymax;
          if ( not(yp GE ymin and yp LE ymax) and yc GE ymin and yc LE ymax  )   OR
             ( yp GE ymin and yp LE ymax and  not(yc GE ymin and yc LE ymax) ) then do;
             if yc ge ymin and yc le ymax then do;
                if yp > ymax then yn=ymax; else yn=ymin;
                xdraw=xc; ydraw=yc;
             end;
             else do;
                if yc > ymax then yn=ymax; else yn=ymin;
                xdraw=xp; ydraw=yp;
             end;
             xn=xp + (yn-yp)*(xc-xp)/(yc-yp);
             if xn ge xmin and xn le xmax then do;
               function='move'; x=xn; y=yn;output;
               function='draw';x=xdraw;y=ydraw;output;
             end;
          end;

          %* Handle Lines that project to the left and right of the range xmin to xmax ;
          if ( not(xp GE xmin and xp LE xmax) and xc GE xmin and xc LE xmax  )   OR
             ( xp GE xmin and xp LE xmax and  not(xc GE xmin and xc LE xmax) ) then do;
             if xc ge xmin and xc le xmax then do;
                if xp > xmax then xn=xmax; else xn=xmin;
                xdraw=xc; ydraw=yc;
             end;
             else do;
                if xc > xmax then xn=xmax; else xn=xmin;
                xdraw=xp; ydraw=yp;
             end;
             yn=yp + (xn-xp)*(yc-yp)/(xc-xp);
             if yn ge ymin and yn le ymax then do;
               function='move'; x=xn; y=yn;output;
               function='draw';x=xdraw;y=ydraw;output;
             end;
          end;
        end;
    end;
    x_prev=tmp_X; y_prev=y&plt_cnt;  cll_prev=cll&plt_cnt;  clu_prev=clu&plt_cnt;
    keep function line x y xsys ysys size color;
           run;
   data _zzanzz_; set _zzanzz_ _zzatzz_;
   run;
   %let annotate=annotate%str(=)_zzanzz_;
%mend;

%macro adj_symb;
         data _NULL_;
          length _symbsz _ebarsz $8;
          if upcase("&SYMBOL")="CIRCLE" then       SYMBSIZE=1.128379167*&SYMBSIZE*&SIZE;
         else if upcase("&SYMBOL")="DIAMOND" then  SYMBSIZE=1.4141213562*&SYMBSIZE*&SIZE;
         else if upcase("&SYMBOL")="TRIANGLE" then SYMBSIZE=1.2*&SYMBSIZE*&SIZE;
         else SYMBSIZE=&SYMBSIZE*&SIZE;
         call symput('WIDTH',put((&WIDTH*&LINWIDTH),8.5));
         _symbsz=put(symbsize,8.5);
         call symput('SYMBSIZE',_symbsz);
         %*********************************************************;
         %* adjust line width                                      ;
         call symput('WIDTH',put((&WIDTH * &LINWIDTH),8.5));
         %*********************************************************;
         %* The annotate units of measure are limited to           ;
         %*    percentage graphics output area,                    ;
         %*    percentage data area, data values,                  ;
         %*    cell in graphics output area,                       ;
         %*    percentage of procedure output area,                ;
         %*    cell in procedure output area                       ;
         %*                                                        ;
         %* This macros base unit of measure is inches.            ;
         %* The ebarsize is related to the available units         ;
         %* of measure by dividing the ebarsize by the length      ;
         %* of the output devices x dimension, in inches, and      ;
         %* multiplying by 100 to give a percent result            ;
         %*********************************************************;

         ebarsize=(0.5 * &ebarsize * &SIZE * 100)/&xinch;
         _ebarsz=put(ebarsize,8.5);
         call symput('EBARSIZE',_ebarsz);
        run;
%mend;

%macro Token(up);
   %local slen qpos lpos bpos epos cpos spos pcount pos count token;
   %let string=%quote(&string);
   %let slen= %length(&string);

   %if &slen > 0 %then %do;
       %let pos=1;
/* I think this throws away leading delineators */
       %do %while( %index(%str(, =;),%qsubstr(&string,&pos,1)) > 0 and &pos < &slen);
           %let pos=%eval(1+&pos);
       %end;
       %let string=%qsubstr(&string,&pos);

       %let qpos= %index(&string,%str(%")); %* position of quote;
       %let lpos= %index(&string,%str(%()); %* position of left parenthesis;
       %let bpos= %index(&string,%str( )); %* position of blank;
       %let epos= %index(&string,%str(=)); %* position of equal sign;
       %let cpos= %index(&string,%str(,)); %* position of comma;
       %let spos= %index(&string,%str(;)); %* position of semicolon;

       %if &bpos = 0 %then %let bpos=&slen;
       %if &epos = 0 %then %let epos=&slen;
       %if &cpos = 0 %then %let cpos=&slen;
       %if &spos = 0 %then %let spos=&slen;
       %if &qpos = 0 %then %let qpos=&slen;
       %if &lpos = 0 %then %let lpos=&slen;

       %if &qpos=1 %then %let pos=%eval(%index(%qsubstr(&string,2),%str(%")) + 1);
       %else %if &lpos=1 %then %do;
          %let pcount=1;
          %let pos=1;
          %do %while( &pcount > 0 and &pcount < 100); %* Parenthesis;
              %let pos=%eval(&pos + 1);
              %if %index(%qsubstr(&string,&pos,1),%str(%)))=1 %then %let pcount=%eval(&pcount - 1);
              %if %index(%qsubstr(&string,&pos,1),%str(%())=1 %then %let pcount=%eval(&pcount + 1);
          %end;
       %end;
       %else %do;
          %let pos=&slen;
          %if &bpos < &pos %then %let pos=&bpos;
          %if &epos < &pos %then %let pos=&epos;
          %if &cpos < &pos %then %let pos=&cpos;
          %if &spos < &pos %then %let pos=&spos;
          %if &qpos < &pos %then %let pos=&qpos;
          %if &lpos < &pos %then %let pos=&lpos;

          %if &pos le &slen %then %let pos=%eval(&pos -1);
       %end;
       %if &pos > 0 %then %let token=%qsubstr(&string,1,&pos); %else %let token=%str();
       %let count=%eval(&pos+1);
/* this removes the head from the string */
       %if &count < &slen %then %do;
           %do %while( %index(%str(, =;),%qsubstr(&string,&count,1)) > 0 and &count < &slen);
               %let count=%eval(1+&count);
           %end;
       %end;
       %if &count < &slen %then %let string=%qsubstr(&string,&count); %else %let string=%str();
       %if %upcase(%substr(&up,1,1))=U %then %let token=%upcase(&token);
   %end;
   %else %let token=END;
   &token
%mend;

%macro _uscan_(delim);
  %local word delim lenword posword begin;
  %let  word=%qscan(%nrbquote(&_string),1,%str(&delim));
  %let  lenword=%eval(%length(%nrbquote(&word)) +1);
  %let  posword=%index(%nrbquote(&_string),&word);
  %let  begin=%eval(&lenword + &posword);
  %if &begin < %length(%nrbquote(&_string)) %then %do;
         %let  _string=%substr(%nrbquote(&_string),&begin);
         %let word=%quote(%upcase(&word));
  %end;
  %else %do;
         %let _string=%str();
         %let word=END;
  %end;
  &word
%mend;


%macro _scan_(delim);
  %local word delim lenword posword begin;
  %let  word=%qscan(%nrbquote(&_string),1,%str(&delim));
  %let  lenword=%eval(%length(%nrbquote(&word)) +1);
  %let  posword=%index(%nrbquote(&_string),&word);
  %let  begin=%eval(&lenword + &posword);
  %let  _string=%substr(%nrbquote(&_string),&begin);
  &word
%mend;

%macro goption;
  %local haxislen vaxislen XAXISRAT GPROLOG FONTRES TARGET RESET GUNIT HTEXT ROTATE GACCESS GSFMODE FTEXT END;
  %let vaxislen=0;
  %let vaxislen=0;
  %let haxislen=0;
  %let ftext=ftext%str(=)&_ftext;
  %let target=%str();                  %let device=device%str(=)ljivps;
  %let linwidth=6;                     %let fontres=fontres=presentation;
  %let rotate=rotate%str(=)landscape;  %let gaccess=gaccess%str(=)gsasfile;
  %let reset=reset%str(=)all;          %let gunit=gunit%str(=)in;
  %let htext=htext%str(=)&SIZE;
  %let gprolog=%str();                 %let gsfmode=gsfmode%str(=)append;
  %let goptstmt=%str();                %let xaxisrat=1.5;
  %let cmndword=%token(up);            %let gout=%str();
  %do %while( &cmndword ne END );
    %let action=%token(lo);
    %if  HTEXT=&cmndword   %then %let _HTEXT=&action;
    %else %if  XAXISRAT=&cmndword %then %let XAXISRAT=&action;
    %else %if  FTEXT=&cmndword   %then %do;
          %let _FTEXT=&action;
          %let ftext=ftext%str(=)&_ftext;
    %end;
    %else %if  LINWIDTH=&cmndword %then %let LINWIDTH=&action;
    %else %if  HAXISLEN=&cmndword %then %let HAXISLEN=&action;
    %else %if  VAXISLEN=&cmndword %then %let VAXISLEN=&action;
    %else %if  CTEXT=&cmndword %then %let CTEXT=&action;
    %else %if  CBACK=&cmndword %then %let CBACK=&action;
    %else %if  CSYMBOL=&cmndword %then %let CSYMBOL=&action;
    %else %let &cmndword=&cmndword%str(=)&action;
    %let cmndword=%token(up);
  %end;
  %set_size(&haxislen,&vaxislen,&xaxisrat);
  data _null_;
    length htext $8;
    htext=put((&_htext * &SIZE),8.5);
    call symput('_HTEXT_',htext);
  run;
  %let HTEXT=%str(htext=&_htext_);
  GOPTIONS &RESET ctitle=&CTITLE ctext=&CTEXT cback=&CBACK csymbol=&csymbol &FONTRES &GUNIT &GPROLOG &TARGET &DEVICE &HTEXT &ROTATE
&GACCESS &GSFMODE &FTEXT;
  %let goptstmt=GOPTIONS &RESET ctitle=&CTITLE ctext=&CTEXT cback=&CBACK csymbol=&csymbol &FONTRES &GUNIT &GPROLOG &TARGET &DEVICE
&HTEXT &ROTATE &GACCESS &GSFMODE &FTEXT GEPILOG="" NODASH;
%mend;

%macro Axis(_axis);
 %local logstyle height logbase aheight color iheight awidth anumber inumber iwidth order width offset label major minor ax_cnt tmp out
anone inone tmpmin tmpmax;

      %***** INITIALIZE AXIS VARIABLES *******;
      %let color=&CTEXT;
      %let logstyle=%str();         %let logbase=%str();
      %let order=%str();            %let lwidth=&LINWIDTH;
      %let offset=%str();           %let _xorigin=%str();
      %let awidth=&LINWIDTH;        %let aheight=1;   %let anumber=%str();
      %let iwidth=&LINWIDTH;        %let iheight=1;   %let inumber=%str();
      %let _yorigin=%str();
      %let label=LABEL=NONE;        %let anone=F;     %let inone=F;
      %let value=value=(h=&NUMSIZE f=&_ftext);
      %if %upcase(&_axis)= X %then %do;
         %let ax_cnt=1;
         %let length=%str(length=&XAXISLEN);
         %let out=x;
      %end;
      %else %do;
         %let ax_cnt=2;
         %let length=%str(length=&YAXISLEN );
         %let out=y;
      %end;
      %***** PROCESS AXIS STATEMENTS *******;
      %let cmndword=%token(up);
      %do %while( &cmndword ne END );
         %if &cmndword=MAJOR %then %do;
            %let _string=%token(up) END%str(;);
            %let cmndword=%_uscan_(%str(=%(%) ));
            %do %while(&cmndword ne END);
                %let cmndword=%str(a&cmndword);
                %if %upcase(&cmndword) = ANONE %then %let ANONE=T;
                %else %let &cmndword=%_scan_(%str(=%(%) ));
                %if %upcase(&cmndword)=ANUMBER %then %let anumber=%str(number=&anumber);
                %let cmndword=%_uscan_(%str(=%(%) ));
            %end;
         %end;
         %else %if &cmndword=MINOR %then %do;
            %let _string=%token(up)%str( )END%str(;);
            %let cmndword=%_uscan_(%str(%(%)= ));
            %do %while(&cmndword ne END);
                  %let cmndword=%str(i&cmndword);
                  %if %upcase(&cmndword) = INONE %then %let INONE=T;
                  %else %let &cmndword=%_scan_(%str(=%)%( ));
                  %if %upcase(&cmndword)=INUMBER %then %let inumber=%str(number=&inumber);
                  %let cmndword=%_uscan_(%str(%(%)= ));
            %end;
         %end;
         %else %if &cmndword=VALUE %then %do;
            %let value=%str(value=)%str(%(h=&NUMSIZE );
            %let _string=%token(lo);
            %let tmp_str=&string;
            %let string=%qsubstr(&_string,2,%length(&_string)-2)%str(,) END%str(;);
            %let cmndword=%token(lo);
            %do %while(&cmndword ne END);
                %if %index(&cmndword,%str(%"))>0 or %index(&cmndword,%str(%'))>0 %then %do;
                    %let value=&value &cmndword;
                %end;
                %else %if %index(%upcase(&cmndword),H)=1 %then %do;
                      %let action=%token(lo);
                      data _null_;
                        length _tmp $8;
                        tmp=&NUMSIZE * &ACTION;
                        _tmp=put(tmp,8.5);
                        call symput('tmp',_tmp);
                      run;
                      %let value=&value %str(h=&TMP );
                %end;
                %else %do;
                   %let value=&value &cmndword=%token(lo);
                %end;
                %let cmndword=%token(lo);
            %end;
            %let value=%unquote(&value%str(%)));
            %let string=&tmp_str;
         %end;
         %else %if &cmndword=WIDTH %then %let lwidth=%token(lo);
         %else %if &cmndword=ORDER %then %do;
            %let ORDER=ORDER=%token(lo);
            %if %index(%upcase(&ORDER),TO) > 1 %then %do;
               %let tmpmin=%scan(&ORDER,2,%STR(=%(%) ));
               %let tmpmax=%scan(&ORDER,4,%STR(=%(%) ));
               %let &out%str(flg)=1;
            %end;
            %else %do;
               %let tmpmin =%scan(&ORDER,2,%STR(=%(%) ));
               %let &out%str(flg)=1;
               %let i=3;
               %let tmp=%scan(&ORDER,&i,%STR(=%(%) ));
               %do %until( %length(&tmp)=0 );
                   %let tmpmax=&tmp;
                   %let &out%str(flg)=1;
                   %let i=%eval(&i + 1);
                   %let tmp=%scan(&ORDER,&i,%STR(=%(%) ));
               %end;
            %end;
            %if &tmpmin > &tmpmax %then %do;
               %let &out%str(max)=&tmpmin;
               %let &out%str(min)=&tmpmax;
            %end;
            %else %do;
               %let &out%str(min)=&tmpmin;
               %let &out%str(max)=&tmpmax;
            %end;
         %end;
         %else %if &cmndword=COLOR or &cmndword=C %then %let color=%token(lo);
         %else %let &cmndword=&cmndword=%token(lo);
         %let cmndword=%token(up);
      %end;
      data _null_;
           length iheigh aheigh _xoffse _yoffse _xorigi  _yorigi $8 ;
           iheight=-&MINRSIZE * &IHEIGHT;
           aheight=-&MAJRSIZE * &AHEIGHT;
           _xoffset= &PIXSIZE * ((&AWIDTH * 1.5)  ) ;
           _yoffset= &PIXSIZE * ((&AWIDTH * 1.5)  ) ;
           xorigin= &XORIGIN - (&PIXSIZE * (&LWIDTH * 2))  ;
           yorigin= &YORIGIN - (&PIXSIZE * (&LWIDTH * 2)) ;
           iheigh=put(iheight,8.5);
           aheigh=put(aheight,8.5);
           _xoffse=put(_xoffset,8.5);
           _yoffse=put(_yoffset,8.5);
           _xorigi=put(xorigin,8.5);
           _yorigi=put(yorigin,8.5);
           call symput('IHEIGHT',iheigh);
           call symput('AHEIGHT',aheigh);
           call symput('_BOFFSET',_xoffse);
           call symput('_EOFFSET',_yoffse);
           call symput('_XORIGIN',_xorigi);
           call symput('_YORIGIN',_yorigi);
       run;

      %let LWIDTH=width=&lwidth;
      %if &INONE=F %then %let minor=%str(minor=%( h=&iheight &inumber w=&iwidth%));
      %else %let minor=%str(minor=NONE);
      %if &ANONE=F %then %let major=%str(major=%( h=&aheight &anumber w=&awidth%));
      %else %let major=%str(major=NONE);
      %if %upcase(&_axis)= Y %then %do;
            %let offset=%str(offset=%(&_BOFFSET,&_EOFFSET%));
            %let origin=%str(origin=%(&XORIGIN,&_YORIGIN%));
      %end;
      %else %do;
            %let offset=%str(offset=%(&_BOFFSET,&_EOFFSET%));
            %let origin=%str(origin=%(&_XORIGIN,&YORIGIN%));
      %end;
      %let width=%str(width=&width);
   %let axis&out=axis&ax_cnt COLOR=&COLOR &LABEL &ORIGIN &LOGSTYLE &LOGBASE &LENGTH &ORDER &VALUE &LWIDTH &MAJOR &MINOR &OFFSET;
%mend;
%macro Bounds;
       %**** Update MinAxis and MaxAxis global variables ****;
       %if &xflg + &yflg < 2 %then %do;
          %if &CLU_EXST = 1 and &CLL_EXST=1 %then %do;
            proc summary data=_zzinzz_ noprint;
               var cll&plt_cnt clu&plt_cnt y&plt_cnt x;
               output
                    out= _zzzzzz_
                    max= cll_max clu_max y_max x_max
                    min= cll_min clu_min y_min x_min;
            data _null_; set _zzzzzz_;
              if &xflg=0  then do;
                    x_max=x_max +((x_max -x_min) * .05);
                    x_min=x_min - ((x_max -x_min) * .05);
%* the following line of code was added as a "fudge" to take care of loss of
   precision as x_min & x_max are transformed to macro variable values ;
                    if x_min = x_max then do; x_max=x_max + 0.00001; x_min = x_min - 0.00001;end;
                   call symput('xmin',put(x_min,10.5));
                   call symput('xmax',put(x_max,10.5));
              end;
              if &yflg=0  then do;
                   y_min=min(cll_min,clu_min,y_min);
                   y_max=max(cll_max,clu_max,y_max);
%* the following line of code was added as a "fudge" to take care of loss of
   precision as y_min & y_max are transformed to macro variable values ;
                    if y_min = y_max then do; y_max=y_max + 0.00001; y_min = y_min - 0.00001;end;
                    y_max=y_max +((y_max -y_min) * .05);
                    y_min=y_min - ((y_max -y_min) * .05);
                   call symput('ymin',put(y_min,10.5));
                   call symput('ymax',put(y_max,10.5));
              end;
            run;
          %end;
          %else %do;
            proc summary data=_zzinzz_ noprint;
               var y&plt_cnt x;
               output
                    out= _zzzzzz_
                    max= y_max x_max
                    min= y_min x_min ;
            data _null_; set _zzzzzz_;
              if &xflg=0 then do;
                    x_max=x_max +((x_max -x_min) * .05);
                    x_min=x_min - ((x_max -x_min) * .05);
%* the following line of code was added as a "fudge" to take care of loss of
   precision as x_min & x_max are transformed to macro variable values ;
                  if x_min = x_max then do; x_max=x_max + 0.00001; x_min = x_min - 0.00001;end;
                  call symput('xmin',put(x_min,10.5));
                  call symput('xmax',put(x_max,10.5));
              end;
              if &yflg=0 then do;
                    y_max=y_max +((y_max -y_min) * .05);
                    y_min=y_min - ((y_max -y_min) * .05);
%* the following line of code was added as a "fudge" to take care of loss of
   precision as y_min & y_max are transformed to macro variable values ;
                  if y_min = y_max then do; y_max=y_max + 0.00001; y_min = y_min - 0.00001;end;
                  call symput('ymin',put(y_min,10.5));
                  call symput('ymax',put(y_max,10.5));
              end;
            run;
          %end;
       %end;
%mend;
%macro Bounds1;
       %**** Update MinAxis and MaxAxis global variables ****;
          %if &xflg=0 %then %do;
            proc summary data=_zzinzz_ noprint;
               var x;
               output
                    out= _zzzzzz_
                    max= x_max
                    min= x_min;
            data _null_; set _zzzzzz_;
              x_min=min(&xmin,x_min);
              x_max=max(&xmax,x_max);
              call symput('xmin',x_min);
              call symput('xmax',x_max);
            run;
          %end;
        %if &yflg=0 %then %do;
          %if &CLU_EXST = 1 and &CLL_EXST=1 %then %do;
            proc summary data=_zzinzz_ noprint;
               var cll&plt_cnt clu&plt_cnt y&plt_cnt x;
               output
                    out= _zzzzzz_
                    max= cll_max clu_max y_max
                    min= cll_min clu_min y_min ;
            data _null_; set _zzzzzz_;
              y_min=min(cll_min,clu_min,y_min,&ymin);
              y_max=min(cll_max,clu_max,y_max,&ymax);
              call symput('ymin',y_min);
              call symput('ymax',y_max);
            run;
          %end;
          %else %do;
            proc summary data=_zzinzz_ noprint;
               var y&plt_cnt ;
               output
                    out= _zzzzzz_
                    max= y_max
                    min= y_min ;
            data _null_; set _zzzzzz_;
              y_min=min(y_min,&ymin);
              y_max=min(y_max,&ymax);
              call symput('ymin',y_min);
              call symput('ymax',y_max);
            run;
          %end;
        %end;
%mend;

%macro _Plot;
%* The macro variable BY is global and originates from the _by macro;
%* The macro variables xmin xmax ymin and ymax are  ;
%* global and are updated both in the axis macro and _plot macro    ;
%* The macro variables SymStmt,P_Stmt are global.  They are created ;
%* in the plot macro and updated in the _plot macro.                ;

%local action color colorpe colorcl cmndword width tmp set linepe linecl ebarsize ebar symbol symbsize x y cll clu mode;

  %let set=%str();           %let linepe=1;
  %let linecl=20;            %let ebar=N;
  %let ebarsize=1;           %let symbol=NONE;
  %let symbsize=0;           %let y=%str();
  %let x=%str();             %let cll=%str();
  %let clu=%str();           %let step=N;
  %let width=1;              %let font=%str();
  %let intrpl=JOIN;          %let ebarwdth=1;
  %let color=&CSYMBOL;       %let mode=include;
  %let colorpe=%str();
  %let colorcl=%str();

  %let cmndword=%token(up);

  %do %while( &cmndword ne END );
    %if &cmndword=C %then %let cmndword=COLOR;
    %let action=%token(no);
    %let &cmndword=&action;
    %if &cmndword=SET %then %do;
       %if %index(&string,%str(%()) = 1 %then %do;
         %let action=%token(no);
         %let SET=&SET&action;
       %end;
    %end;
    %let cmndword=%token(up);
  %end;
  %if %length(&font) > 1 %then %let font=%str(f=)&font;
  ***** adjust symbol sizes to provide "equal" visual impact *****;
  %adj_symb;
  ***** build symbol statements *******;
  %if &LINEPE = 0 %then %let INTRPL = NONE;
  %else %if %upcase(&STEP) = L or &STEP = R %then %let INTRPL = STEPJ&STEP;
  %ELSE %let INTRPL = JOIN;
  %if &SYMBSIZE = 0 or &SYMBOL=NONE %then %do;
       %let SYMBOL=NONE;
       %let SYMBSIZE=%str();
  %end;
  %else %let SYMBSIZE=h=&SYMBSIZE;

  *the next line avoids spurious error messages;
  %if &LINEPE = 0 %then %let LINEPE=1;

  %let colorpe=&color;
  %let colorcl=&color;


%let symstmt=&symstmt  symbol&L_CNT l=&LINEPE COLOR=&colorpe v=&SYMBOL &SYMBSIZE i=&INTRPL w=&WIDTH &FONT MODE=&MODE%str(;);
  %*now we change linepe back to 0 if intrpl=none;
  %if &INTRPL=NONE %then %let linepe=0;

  %let p_stmt=&p_stmt  Y&plt_cnt*X=&L_CNT;

   %***** detect presence of CLL, CLU, and BY variables ******;
        %let CLU_EXST=0;
        %let CLL_EXST=0;
   %if %length(&cll > 0) or %length(&clu) > 0 or %length(&by) > 0 %then %do;
        %let BY_EXST=0;
        proc contents short data=%scan(&set,1,%str(%()) out=_xyyxx_ noprint;
        data _null_; set _xyyxx_;
           if upcase(name) = upcase("&CLU") then call symput('CLU_EXST',"1");
           if upcase(name) =upcase("&CLL") then call symput('CLL_EXST',"1");
       %if %length(&BY) > 0 %then %do;
           if upcase(name) =upcase("&BY") then call symput('BY_EXST',"1");
       %end;
        run;
        %if %length(&BY) > 0 and &BY_EXST=0 %then %put("ERROR in BY STATEMENT");
   %end;

  %if &CLL_EXST = 1 and &CLU_EXST=1 %then %do;
     %if &LINECL = 0 %then %do;
         %let INTRPL = NONE;
       *the next line avoids spurious error messages;
              %let LINECL = 2;
     %end;
     %ELSE %if %upcase(&STEP) = L or &STEP = R %then %let INTRPL = STEPJ&STEP;
     %ELSE %let INTRPL = JOIN;

     %let L_CNT = %eval(&L_CNT + 1);

     %let symstmt=&symstmt symbol&L_CNT COLOR=&colorcl l=&LINECL v=NONE i=&INTRPL w=&WIDTH MODE=&MODE %str(;);

     %*now we change linecl back to 0 if intrpl=none;
     %if &INTRPL=NONE %then %let linecl=0;

     %let p_stmt= &p_stmt CLL&plt_cnt*X=&L_CNT CLU&plt_cnt*X=&L_CNT;
  %end;

   %***** build data set and annotate data sets ****************;

        %if &CLU_EXST = 1 and &CLL_EXST=1 %then %do;
          %let KEEP=x y&plt_cnt cll&plt_cnt clu&plt_cnt &BY;
          %let RENAME=rename=(&X=X &Y=y&plt_cnt &CLL=cll&plt_cnt &CLU=clu&plt_cnt);
        %end;
        %else %do;
          %let RENAME=rename=(&X=X &Y=y&plt_cnt);
          %let KEEP=x y&plt_cnt &BY;
        %end;
        %let tmp=%scan(&SET,2,()=);
        %let beg=%eval(%length(%scan(&SET,1,()=)) + 1);
        %if  %upcase(&tmp)=WHERE %then
              %let set=%substr(&set,1,&beg)&RENAME%substr(&set,&beg + 1);
        %else %let set=%scan(&SET,1,()=)(&RENAME);
        data _zzinzz_; set &SET;
          keep &KEEP;
      %**** Get the X and Y axis max and min values         *******;
        %bounds;
      %**** build annotate data set that creates error bars *******;
       %if &ebar = 1 %then %do;
          %bld_anno(_zzinzz_,&width,&ebarwdth,&ebarsize,&colorpe);
       %end;

       **** build annotate data set to correct for "clipping" errors ***************;
       **** See comments section at beginning of file for explantation *************;
       ** flagged out 08/12/96 as no longer needed, now use mode = include  **;
       %*if (&xflg=1 or &yflg=1)  and ( &linepe>0 or &linecl > 0)  and &STEP=N %then %do;
          %*bldano_c1(&width,&linepe,&linecl,&colorpe,&colorcl);
       %*end;

       ***** Set those points outside ymin and ymax bounds to missing *****;
       ***** This step is req'd to "fix" a peculiarity in the way gplot       *****;
       ***** handles points that lay above the upper bound vs. below the lower ****;
       ***** bound. We don't want to do this until after the annotate data set ****;
       ***** is built.                                                         ****;

       ** flagged out 08/12/96 as no longer needed, now use mode = include  **;
       %if T=F and (&xflg=1 or &yflg=1) and ( &linepe>0 or &linecl > 0)  and &STEP=N %then %do;
        data _zzinzz_; set _zzinzz_;
          if &yflg=1 then do;
             if y&plt_cnt > &ymax or y&plt_cnt < &ymin then y&plt_cnt = .;
             if cll&plt_cnt > &ymax or cll&plt_cnt < &ymin then cll&plt_cnt = .;
             if clu&plt_cnt > &ymax or clu&plt_cnt < &ymin then clu&plt_cnt = .;
          end;
          if &xflg=1 then do;
             if x < &xmin or x > &xmax then delete;
          end;
        run;
       %end;

      **** Merge the data set into one big one that contains data for all   ******:
      **** Tuple statements.                                                ******;

        proc sort data=_zzinzz_; by &by x;
        run;
        %if &plt_cnt > 1 %then %do;
          proc sort data=_zzplzz_; by &by x;
          data _zzplzz_; merge _zzplzz_ _zzinzz_; by &by x;
        %end;
        %else %do;
          data _zzplzz_;  set _zzinzz_;
        %end;
        run;

  ****** End build data set section ***************************;
  %let L_CNT = %eval(&L_CNT + 1);
%mend;%*end macro _plot ;

%macro Connect;
%local color line cmndword x1 x2 x3 x4 width ;
   %let x1=%str();
   %let x2=%str();
   %let x3=%str();
   %let x4=%str();
   %let LINE=%str();
   %let cmndword=%token(up);

   data _zzatzz_;
     length function $8;
     length color $8;
     attrib xsys ysys format=$1.;
     size=&linwidth;
     line=1;
     xsys='2'; ysys='2';
     color="&CSYMBOL";
     %do %while(&cmndword ne END);
        %if &cmndword = LINE %then %do;
           %Let line=%token(lo);
           line=&line;
        %end;
        %else %if &cmndword = WIDTH %then %do;
          %let  width=%token(lo);
                size=&width * &linwidth;
        %end;
        %else %if &cmndword = POINTS %then %do;
            %let _string=%token(lo)%str(,) END%str(;);
            %let cmndword=%_uscan_(%str(=;,%(%) ));
            %let i=3;
            %do %while("&cmndword" ne "END");
                %let x&i=&cmndword;
                %if &i=4 %then %do;
                     function='move';x=&x3;y=&x4;output;
                     %let i=1;
                %end;
                %else %if &i=2 %then %do;
                     function='draw';x=&x1;y=&x2;output;
                     %let i=1;
                %end;
                %else %let i=%eval(&i + 1);
                %let cmndword=%_uscan_(%str(=;,%(%) ));
            %end;
         %end;
         %else %if &cmndword = COLOR %then %do;
             %do;%let tmp=%token(lo);%end;
             %do; color="&tmp"; %end;
          %end;
     %let cmndword=%token(up);
     %end;
         keep x y line size function xsys ysys color;
   run;

   data _zzanzz_; set _zzanzz_ _zzatzz_;
   run;
   %let annotate=annotate%str(=)_zzanzz_;

%mend;

%macro _id;
%local  L;
  %let L=%str();
  %let cmndword=%token(up);
  %do %while( &cmndword ne END );
    %let action=%token(no);
    %if &cmndword=L %then %let &cmndword=&action;
    %let cmndword=%token(up);
  %end;
  %let identif= footnote1 f=swiss h=.75 pct move=(0,.5) pct %unquote(&L) h=.75 pct "   &SYSDATE    &SYSTIME";
%mend;


%macro _By;
%local byline;
  %let byline=0;
  %do %while( &cmndword ne END );
    %let action=%token(lo);
    %let &cmndword=&action;
    %let cmndword=%token(up);
  %end;
  %if &byline=0 %then %do;
    %let OPTSTMT= OPTION nobyline;
  %end;
  %else %do;
     %let OPTSTMT= OPTION BYLINE;
     %let goptstmt=&goptstmt fby=&_ftext hby=&_htext_;
  %end;
%mend;

%macro Labl_pos(_axis);
    data _null_;
      length ypos xpos $8 ;
      if "&_1st_"="Y" then do;
         if "&_axis"="X" then do;
              xpos=put(&xaxctr-(&curlen*.5)-0.19,8.5);
              ypos=put(&XLBLPOS,8.5);
         end;
         if "&_axis"="T" then do;
              xpos=put(&xaxctr-(&curlen*.5)-0.19,8.5);
              ypos=put(&TLBLPOS,8.5);
         end;
         else if "&_axis"="Y" then do;
             ypos=put((&yaxctr-&curlen*.5),8.5);
             xpos=put(&YLBLPOS,8.5);
         end;
         else if "&_axis"="2" or "&_axis"="1" then do;
              xpos=put((&XORIGIN+&XAXISLEN*.05),8.5);
              ypos=put((&_YORIGIN+&YAXISLEN*.95),8.5);
         end;
         else if "&_axis"="3" or "&_axis"="4" then do;
             xpos=put((&XORIGIN+&XAXISLEN*.05),8.5);
             ypos=put((&_YORIGIN+&YAXISLEN*.1),8.5);
         end;
      end;
      else do;
         if "&_axis"="X" then do;
           xpos=put((&xaxctr-&curlen*.5),8.5);
           ypos="-"||put(&linespac,8.5);
         end;
         if "&_axis"="T" then do;
           xpos=put((&xaxctr-&curlen*.5),8.5);
           ypos="-"||put(&linespac,8.5);
         end;
         else if "&_axis"="Y" then do;
           ypos=put((&yaxctr-&curlen*.5),8.5);
           xpos="+"||put(&linespac,8.5);
         end;
         else if "&_axis"="2" or "&_axis"="3" then do;
           xpos=&_1stxpos;
           ypos="-"||put(&linespac,8.5);
         end;
         else if "&_axis"="1" or "&_axis"="4" then do;
           xpos='-_@_-';
           ypos="-"||put(&linespac,8.5);
         end;
         else do;
           xpos="-"||put(&curlen,8.5);
           ypos="-"||put(&linespac,8.5);
         end;
      end;
      call symput('XPOS',xpos); call symput('YPOS',ypos);
    run;
    %if &_1st_=Y %then %do;
           %let tempnote=&tempnote &label;
           %let _1stypos=&ypos;
           %let _1stxpos=&xpos;
           %let priorlen=&curlen;
    %end;
    %else %do;
        %let tempnote=&tempnote move=(&XPOS,&YPOS) &label;
       %let priorlen=&curlen;
    %end;
    %let _1st_=N;
%mend;

%macro _Label(_axis);
%local curlen _1stxpos _1stypos height font move label _1st_y oheight
 _yorigin linespac tmp maxlen priorlen x ;
%* commands are L F H SUB SUP BUL NL;
%* Fairly straight forward.;
%* Except the inital positioning,which are explicit moves, all moves are relative.;
%* So pay attention to the statements related to positioning, the logic is
%* admittedly tortuous.  Note: move statements must be seperated by;
%* printable text, otherwise only the last move in the sequence is recognized;
  %let label=%str();
  %let tempnote=%str();
  %let _1st_=Y;               %let maxlen=0;
  %let curlen=0;
***  adjust for SAS V8 vs V6.12, the macro variable  curlen   was found to be 
***   a ratio between the two versions (v6.12 & v8) of 0.7317777 ;
  %let newratio=%str( * 1 );
%*%if &sysver>=7.0 %then %let newratio=%str( * 1/0.731778 );
  %if &sysver>=7.0 %then %let newratio=%str( * 1/0.79); %* EHB fudge 08/18/2001;
  %let priorlen=0;
  %let _1stypos=0;            %let _1stxpos=0;
  %let height=&_htext_;       %let font=&_ftext;
  %let linespac=&linspace;
  %let _yorigin=&yorigin;
  %let cmndword=%token(u);
  %do %while( &cmndword ne END );
    %if &cmndword=L %then %do;
       %let action=%token(l);
       %let label=&label &action;
       data _null_;
            rc1=ginit();   rc2=graph('clear');
            x=0; y=0;
            length cur_len $8;
            err=gset('TEXFONT',"&FONT");
            err=gset('TEXHEIGHT',&HEIGHT);
             call gask('TRANSNO',n,err);
             call gask('TRANS',n,vllx,vlly,vurx,vury,wllx,wlly,wurx,wury,err);
             err=gset('TEXALIGN','CENTER','HALF');
             call gask('HSIZE',hsize,err);
             call    gask('TEXEXTENT',x,y,"&action",xend,yend,x1,x2,x3,x4,y1,y2,y3,y4,err);
             curlen=%unquote(&curlen)+(3 * hsize * xend/10 )*.6 %unquote(&newratio) ;
             cur_len=put(curlen,8.5);
             call symput('curlen',cur_len);
      run;
    %end;
    %else %if &cmndword=BUL %then %let label=&label f=special "J" f=&font;
    %else %if &cmndword=SUB or &cmndword=SUP %then %do;
       %let action=%token(l);
       data _null_;
            length st_coun oheigh mov $8;
            rc1=ginit();   rc2=graph('clear');
            oheight=%unquote(&height)*0.5;
            if "&cmndword"="SUB" then move=%unquote(&height)*0.25;
            else move=%unquote(&height)*0.65;
            x=0; y=0;
            err=gset('TEXALIGN','CENTER','HALF');
            call gask('TEXEXTENT',x,y,"&action",xend,yend,x1,x2,x3,x4,y1,y2,y3,y4,err);
            curlen=%unquote(&curlen)+(xend /4.871)*.5*.6 %unquote(&newratio) ;
            st_coun=put(curlen,8.5);
            oheigh=put(oheight,8.5);
            mov=put(move,8.5);
            call symput('curlen',st_coun);
            call symput('oheight',oheigh);
            call symput('move',mov);
       run;
       %if &_axis=Y %then %do;
          %if &cmndword=SUB %then
               %let label=&label h=&oheight move=(+&move,-0) &action h=&height move=(-&move,-0);
          %else
               %let label=&label h=&oheight move=(-&move,-0) &action h=&height move=(+&move,-0);
       %end;
       %else %do;
          %if &cmndword=SUB %then
               %let label=&label h=&oheight move=(-0,-&move) &action h=&height move=(-0,+&move);
          %else
               %let label=&label h=&oheight move=(-0,+&move) &action h=&height move=(-0,-&move);
       %end;
    %end;
    %else %if &cmndword=NL %then %do;
       %labl_pos(&_axis);
       %if &curlen > &maxlen %then %let maxlen=&curlen;
       %let curlen=0;
       %let label=%str();
       %if &_axis=Y %then %do;
         data _null_;
           length _1stxpos $8 ;
              _1stxpos=put((&_1stxpos - &linespac),8.5);
              call symput('_1stxpos',_1stxpos);
         run;
       %end;
       %else %if &_axis=3 or &_axis=4 %then %do;
         data _null_;
           length _1stypos $8 ;
              _1stypos=put((&_1stypos + &linespac),8.5);
              call symput('_1stypos',_1stypos);
         run;
       %end;
    %end;
    %else %if &cmndword=H %then %do;
       %let action=%token(l);
       data _null_;
           length height $8;
           height=put((&_HTEXT_*&action),8.5);
           linespac=put((height * 1.1),8.5);
           call symput('height',height);
           call symput('linespac',linespac);
       run;
       %let label=&label h=&height;
    %end;
    %else %if &cmndword=F %then %let label=&label f=%token(l);
    %else %let label=&label &cmndword=%token(l);
    %let cmndword=%token(u);
  %end;

  %if &curlen > &maxlen %then %let maxlen=&curlen;
  %labl_pos(&_axis);

  %if &_axis=1 or &_axis=4 %then %do;
     data _null_;
        length _1stxpos $8 ;
        _1stxpos=put((&xorigin+&xaxislen - &maxlen),8.5);
        call symput('_1stxpos',_1stxpos);
     run;
     %do %while(%index(&tempnote,-_@_-) > 1);
         %let x=%index(&tempnote,-_@_-);
         %let tempnote=%qsubstr(&tempnote,1,&x-1)&_1stxpos%qsubstr(&tempnote,&x+5);
     %end;
  %end;
  %if &_axis=Y %then
      %let note=&note h=&_htext_ f=&_ftext langle=90 move=(&_1stxpos,&_1stypos) color=&CTEXT &tempnote;
  %else
      %let note=&note h=&_htext_ f=&_ftext langle=0 move=(&_1stxpos,&_1stypos) color=&CTEXT &tempnote;
%mend;


%macro dummy;
%let end=%eval(%index(%nrbquote(%upcase(&string)),%str(END)) + 4);
%put end=&end  length=%length(%nrbquote(&string));
%if &end ge %length(%nrbquote(&string)) %then %let string= END ;
%else %let string=%substr(%nrbquote(&string),&END));
%put string=> &string;
%mend;

%macro plot/parmbuff;
%local test annotate l_cnt p_stmt plt_cnt _ftext _htext _htext_
       goptstmt optstmt symstmt device linspace linwidth size
       numsize xinch pixsize majrsize minrsize logosize note
       yinch xaxislen yaxislen xorigin yorigin _boffset _eoffset
       tlblpos xlblpos ylblpos xactr yaxctr by notes axisx axisy xmax
       xmin ymax ymin xflg yflg axisxflg
       axisyflg identif _string
       tmp cmndword string;
   %******************************************************;
   %* Set global variables                               *;
   %******************************************************;
   options nonotes;

   data _zzanzz_; set _NULL_;
   %let ctext=BLACK;
   %let cback=WHITE;
   %let ctitle=BLACK;
   %let csymbol=BLACK;
   %let test=f;
   %let annotate=%str();
   %let l_cnt=1;           %let p_stmt=%str();     %let plt_cnt=0;
   %let _ftext=SWISS;      %let gout=%str();
   %let _htext=1;           %let _htext_=%str();
   %let goptstmt=%str();    %let optstmt=%str();
   %let symstmt=%str();
   %let device=%str();
   %let linspace=%str();
   %let linwidth=%str();   %let pixsize=%str();
   %let size=%str();       %let majrsize=%str();
   %let numsize=%str();    %let minrsize=%str();
   %let logosize=%str();
   %Let note=%str(note );
   %let xinch=%str();      %let yinch=%str();
   %let xaxislen=%str();   %let yaxislen=%str();
   %let xorigin=%str();    %let yorigin=%str();
   %let _boffset=%str();   %let _eoffset=%str();
   %let xlblpos=%str();    %let ylblpos=%str();
   %let tlblpos=%str();
   %let xaxctr=%str();     %let yaxctr=%str();
   %let by=%str();         %let notes=nonotes;
   %let axisx=%str();      %let axisy=%str();
   %let xmax=%str(.);       %let ymax=%str(.);
   %let xmin=%str(.);       %let ymin=%str(.);
   %let axisxflg=%str();   %let axisyflg=%str();
   %let identif=%str();
   %let xflg=0; %let yflg=0;
   %let _string=end%str(;);
   %let tmp=%nrbquote(&syspbuff);
   %let string=%nrbquote(%substr(&tmp,2,%length(&tmp)-2));
   %let cmndword=%token(u);
*********************************************************************************************;
* Make interoperable with SAS 6.12 and SAS 8.2;
  %let useframe=;
  %if &sysver>=7.0 %then %let useframe = noframe;
  %put *** ==>  sas version is &sysver;

  %if &cmndword=GOPTIONS %then %do;
        %goption;
   %end;
   %else %do;
        %let string=END%str(;)&cmndword &string;
        %goption;
   %end;
   %let cmndword=%token(u);
   %do %while(&cmndword ne END ) ;
      %if &cmndword=GOPTIONS %then %do;
      %end;
      %else %if &cmndword=AXISX %then %do;
         %let axisxflg=T;
         %axis(x);
      %end;
      %else %if &cmndword=AXISY %then %do;
          %let axisyflg=T;
          %axis(y);
      %end;
      %else %if &cmndword=TUPLE %then  %do;
          %let plt_cnt=%eval(&plt_cnt + 1);
          %_plot;
      %end;
      %else %if &cmndword=BY %then  %do;
          %_by;
      %end;
      %else %if %index(&cmndword,TITLE)=1 %then  %do;
          %_LABEL(T);
      %end;
      %else %if &cmndword=CONNECT %then  %do;
          %connect;
      %end;
      %else %if %index(&cmndword,LABEL)=1 %then  %do;
        %*options mprint mlogic;
          %_LABEL(%substr(&cmndword,%length(&cmndword),1));
        %*options nomprint nomlogic;
      %end;
      %else %if %index(&cmndword,LOGO)=1 %then  %do;
          %_LABEL(%substr(&cmndword,%length(&cmndword),1));
      %end;
      %else %if &cmndword=NOTES %then %do;
          %let test=t;
          options notes;
      %end;
      %else %if &cmndword=ID %then %do;
           %_id;
      %end;
      %else %do ;
          %put ERROR IN MAIN PLOT LOOP;
          %dummy;
      %end;
      %let cmndword=%token(u);
   %end;

%if &axisxflg ne T %then %do;
   %let string=end%str(;);
   %axis(x);
%end;
%if &axisyflg ne T %then %do;
   %let string=end%str(;);
   %axis(y);
%end;

%if %length(&by)>0 %then %do;
   %let by= by &by;
   proc sort data=_zzplzz_; &by;
%end;
%if &test=t or 1=0 %then %do;
   %put &goptstmt;
   %put &optstmt;
   %put &axisx;
   %put &axisy;
   %put &symstmt;
   %put &identif;
   %put proc gplot data=_zzplzz_ &gout &annotate;
   %put   &by;
   %put   &note;
   %put   plot &p_stmt /overlay vaxis=axis2 haxis=axis1;
   proc print data=_zzanzz_;
   proc print data= _zzplzz_;
%end;

&goptstmt;
&optstmt;
&axisx;
&axisy;
%unquote(&symstmt);
%unquote(&identif);
  proc gplot data=_zzplzz_ nocache &gout &annotate;
     &by;
      %unquote(&note);
     plot &p_stmt /overlay vaxis=axis2 haxis=axis1 &useframe;
  run;
options notes;
%put &goptstmt;
quit;
%mend;



